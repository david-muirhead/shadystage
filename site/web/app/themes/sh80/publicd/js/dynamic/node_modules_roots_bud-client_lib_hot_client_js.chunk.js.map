{"version":3,"file":"js/dynamic/node_modules_roots_bud-client_lib_hot_client_js.chunk.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@roots/bud/sage/sage/../node_modules/@roots/bud-client/lib/hot/client.js","webpack://@roots/bud/sage/sage/../node_modules/@roots/bud-client/lib/hot/components/index.js","webpack://@roots/bud/sage/sage/../node_modules/@roots/bud-client/lib/hot/events.js","webpack://@roots/bud/sage/sage/../node_modules/@roots/bud-client/lib/hot/log.js","webpack://@roots/bud/sage/sage/../node_modules/@roots/bud-client/lib/hot/options.js"],"sourcesContent":["/* eslint-disable no-console */\n/* global __resourceQuery */\n/* global __webpack_hash__ */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as components from './components/index.js';\nimport { injectEvents } from './events.js';\nimport { makeLogger } from './log.js';\nimport * as clientOptions from './options.js';\n/**\n * Initializes bud.js HMR handling\n */\nexport const client = (queryString, webpackHot) => __awaiter(void 0, void 0, void 0, function* () {\n    /* Guard: EventSource browser support */\n    if (typeof (window === null || window === void 0 ? void 0 : window.EventSource) === `undefined`) {\n        console.error(`[bud] hot module reload requires EventSource to work. https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools`);\n        return false;\n    }\n    /* Guard: webpackHot api availability */\n    if (!webpackHot) {\n        console.error(`[bud] hot module reload requires the webpack hot api to be available`);\n        return false;\n    }\n    /* Set client options from URL params */\n    const options = clientOptions.setFromParameters(queryString);\n    /* Setup logger */\n    const logger = makeLogger(options);\n    if (typeof window.bud === `undefined`) {\n        window.bud = {\n            current: {},\n            hmr: {},\n            controllers: [],\n            listeners: {},\n        };\n    }\n    if (!window.bud.current[options.name]) {\n        window.bud.current[options.name] = null;\n    }\n    const isStale = (hash) => {\n        if (hash)\n            window.bud.current[options.name] = hash;\n        return __webpack_hash__ === window.bud.current[options.name];\n    };\n    /**\n     * Webpack HMR check handler\n     */\n    const check = () => __awaiter(void 0, void 0, void 0, function* () {\n        if (webpackHot.status() === `idle`) {\n            yield webpackHot.check(false);\n            requestAnimationFrame(function whenReady() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (webpackHot.status() === `ready`) {\n                        yield update();\n                    }\n                    else {\n                        requestAnimationFrame(whenReady);\n                    }\n                });\n            });\n        }\n    });\n    /**\n     * Webpack HMR unaccepted module handler\n     */\n    const onUnacceptedOrDeclined = (info) => {\n        console.warn(`[${options.name}] ${info.type}`, info);\n        options.reload && window.location.reload();\n    };\n    /**\n     * Webpack HMR error handler\n     */\n    const onErrored = (error) => {\n        window.bud.controllers.map(controller => controller === null || controller === void 0 ? void 0 : controller.update({\n            errors: [error],\n        }));\n    };\n    /**\n     * Webpack HMR update handler\n     */\n    const update = () => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            yield webpackHot.apply({\n                ignoreUnaccepted: true,\n                ignoreDeclined: true,\n                ignoreErrored: true,\n                onErrored,\n                onUnaccepted: onUnacceptedOrDeclined,\n                onDeclined: onUnacceptedOrDeclined,\n            });\n            if (!isStale())\n                yield check();\n        }\n        catch (error) {\n            logger.error(error);\n        }\n    });\n    /* Instantiate indicator, overlay */\n    yield components.make(options);\n    /* Instantiate eventSource */\n    const events = injectEvents(EventSource).make(options);\n    if (!window.bud.listeners[options.name]) {\n        window.bud.listeners[options.name] = (payload) => __awaiter(void 0, void 0, void 0, function* () {\n            var _a;\n            if (!payload)\n                return;\n            if (options.reload && payload.action === `reload`)\n                return window.location.reload();\n            if (payload.name !== options.name)\n                return;\n            window.bud.controllers.map(controller => controller === null || controller === void 0 ? void 0 : controller.update(payload));\n            if (((_a = payload.errors) === null || _a === void 0 ? void 0 : _a.length) > 0)\n                return;\n            if (payload.action === `built` || payload.action === `sync`) {\n                if (isStale(payload.hash))\n                    return;\n                if (payload.action === `built`) {\n                    logger.log(`built in ${payload.time}ms`);\n                }\n                yield check();\n            }\n        });\n        /*\n         * Instantiate HMR event source\n         * and register client listeners\n         */\n        events.addListener(window.bud.listeners[options.name]);\n    }\n});\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const make = (options) => __awaiter(void 0, void 0, void 0, function* () {\n    if (options.indicator && !customElements.get(`bud-activity-indicator`)) {\n        yield import(`./indicator/index.js`)\n            .then(makeController)\n            .then(maybePushController);\n    }\n    if (options.overlay && !customElements.get(`bud-error`)) {\n        yield import(`./overlay/index.js`)\n            .then(makeController)\n            .then(maybePushController);\n    }\n    return window.bud.controllers;\n});\nconst makeController = (module) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!module)\n        return;\n    return yield module.make();\n});\nconst maybePushController = (controller) => {\n    if (!controller)\n        return;\n    window.bud.controllers.push(controller);\n};\n","/* eslint-disable no-console */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const injectEvents = (eventSource) => {\n    /**\n     * EventSource wrapper\n     *\n     * @remarks\n     * wraps EventSource in a function to allow for\n     * mocking in tests\n     */\n    return class Events extends eventSource {\n        /**\n         * Class constructor\n         *\n         * @remarks\n         * Singleton interface, so this is private.\n         *\n         * @public\n         */\n        constructor(options) {\n            super(options.path);\n            this.options = options;\n            /**\n             * Registered listeners\n             *\n             * @public\n             */\n            this.listeners = new Set();\n            /**\n             * EventSource `onopen` handler\n             * @public\n             */\n            this.onopen = function () { };\n            /**\n             * EventSource `onmessage` handler\n             * @public\n             */\n            this.onmessage = function (payload) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (!(payload === null || payload === void 0 ? void 0 : payload.data) || payload.data == `\\uD83D\\uDC93`) {\n                        return;\n                    }\n                    try {\n                        const data = JSON.parse(payload.data);\n                        if (!data)\n                            return;\n                        yield Promise.all([...this.listeners].map((listener) => __awaiter(this, void 0, void 0, function* () {\n                            return yield listener(data);\n                        })));\n                    }\n                    catch (ex) { }\n                });\n            };\n            this.onopen = this.onopen.bind(this);\n            this.onmessage = this.onmessage.bind(this);\n            this.addListener = this.addListener.bind(this);\n        }\n        /**\n         * Singleton constructor\n         *\n         * @public\n         */\n        static make(options) {\n            if (typeof window.bud.hmr[options.name] === `undefined`)\n                Object.assign(window.bud.hmr, {\n                    [options.name]: new Events(options),\n                });\n            return window.bud.hmr[options.name];\n        }\n        /**\n         * EventSource `addMessageListener` handler\n         * @public\n         */\n        addListener(listener) {\n            this.listeners.add(listener);\n            return this;\n        }\n    };\n};\n","/* eslint-disable no-console */\nexport const makeLogger = (options) => {\n    return {\n        log: makeLog(options),\n        error: makeError(options),\n        warn: makeWarn(options),\n        info: makeInfo(options),\n    };\n};\nlet lastLog = null;\nexport const makeLog = options => {\n    return (...args) => {\n        if (options.log) {\n            if (lastLog === args.join(``))\n                return;\n            lastLog = args.join(``);\n            console.log(`[${options.name}]`, ...args);\n        }\n    };\n};\nexport const makeInfo = options => {\n    return (...args) => {\n        if (options.log) {\n            console.info(`[${options.name}]`, ...args);\n        }\n    };\n};\nexport const makeError = options => {\n    return (...args) => {\n        console.error(`[${options.name}]`, ...args);\n    };\n};\nexport const makeWarn = options => {\n    return (...args) => {\n        console.warn(`[${options.name}]`, ...args);\n    };\n};\n","/**\n * Client options\n */\nlet data = {\n    timeout: 2000,\n    reload: true,\n    name: `@roots/bud-client`,\n    debug: true,\n    log: true,\n    indicator: true,\n    overlay: true,\n    path: `/bud/hot`,\n};\n/**\n * Get client option\n */\nconst get = (name, key) => key ? data[name][key] : data[name];\n/**\n * Set client data based on URL parameters\n */\nconst setFromParameters = (query) => {\n    let parsedParams = {};\n    new window.URLSearchParams(query).forEach((value, key) => {\n        parsedParams[key] =\n            value === `true` ? true : value === `false` ? false : value;\n    });\n    data[parsedParams.name] = Object.assign(Object.assign({}, data), parsedParams);\n    return data[parsedParams.name];\n};\nexport { data, get, setFromParameters };\n"],"names":[],"sourceRoot":""}